{% extends "layout.html" %}

{% block title %}T H E&nbsp;&nbsp;V O I D{% endblock %}

{% block extra_css %}
<style>
    body { cursor: none; }

    .scream {
        position: absolute;
        white-space: nowrap;
        pointer-events: none;
        opacity: 0;
        animation: fadeIn 2s forwards;
        transition: opacity 0.5s ease;
    }

    @keyframes fadeIn {
        to { opacity: var(--target-opacity, 0.8); }
    }

    #void-container {
        width: 100vw;
        height: 100vh;
        position: relative;
        filter: blur(0.5px) contrast(1.1);
        transition: filter 5s ease;
    }

    #eye-glyph {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        display: flex;
        gap: 60px;
        opacity: 0.35;
        pointer-events: auto;
        filter: blur(0.4px);
        z-index: 100;
        transition: opacity 0.4s ease;
    }

    .eye {
        width: 120px;
        height: 48px;
        border: 2px solid rgba(255, 255, 255, 0.4);
        border-radius: 60% / 90%;
        position: relative;
        animation: slowPulse 6s ease-in-out infinite;
    }

    .eye::after {
        content: '';
        position: absolute;
        width: 22px;
        height: 22px;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.6);
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        box-shadow: 0 0 15px rgba(255, 255, 255, 0.45);
    }

    .eye.left::after { box-shadow: -6px 0 20px rgba(255,255,255,0.3); }
    .eye.right::after { box-shadow: 6px 0 20px rgba(255,255,255,0.3); }

    @keyframes slowPulse {
        0%, 100% { transform: scaleX(1); }
        50% { transform: scaleX(0.8); }
    }

    body.eyes-open #eye-glyph {
        opacity: 0.9;
        filter: none;
    }

    body.eyes-open #void-container .scream {
        opacity: 1 !important;
        color: rgba(255, 255, 255, 0.95) !important;
        text-shadow: 0 0 18px rgba(255, 255, 255, 0.6);
    }
    
    /* Blink Mode - Squinting Eyes */
    body.blink-mode .eye {
        height: 12px; /* Much narrower */
        border-radius: 50% / 80%;
        border-width: 3px;
        background: rgba(0, 0, 0, 0.5);
        animation: squintPulse 4s ease-in-out infinite;
    }

    body.blink-mode .eye::after {
        width: 14px;
        height: 14px;
        /* Pupil moves slightly */
        animation: search 10s infinite;
    }

    @keyframes squintPulse {
        0%, 100% { transform: scaleX(1); }
        50% { transform: scaleX(0.9); }
    }

    @keyframes search {
        0%, 100% { transform: translate(-50%, -50%); }
        20% { transform: translate(-20%, -50%); }
        40% { transform: translate(-80%, -50%); }
        60% { transform: translate(-50%, -50%); }
        80% { transform: translate(-50%, -50%); }
    }

    .return-link {
        position: fixed;
        bottom: 40px;
        left: 50%;
        transform: translateX(-50%);
        color: #888;
        text-decoration: none;
        font-size: 1.8rem;
        z-index: 1000;
        opacity: 0.6;
        transition: all 0.3s;
        cursor: pointer;
        border: 1px solid #444;
        padding: 15px 30px;
        background-color: rgba(0,0,0,0.8);
        letter-spacing: 3px;
        box-shadow: 0 0 10px rgba(0,0,0,1);
    }
    
    #fall-deeper-btn {
        bottom: 120px;
        font-size: 1.2rem;
        border-color: #600;
        color: #a00;
        opacity: 0.4;
    }
    
    #fall-deeper-btn:hover {
        border-color: #f00;
        color: #f00;
        text-shadow: 0 0 10px #f00;
        box-shadow: 0 0 20px rgba(255, 0, 0, 0.4);
        animation: shake 0.2s infinite;
    }

    .return-link:hover {
        color: #fff;
        border-color: #fff;
        opacity: 1;
        box-shadow: 0 0 20px rgba(255, 255, 255, 0.4), inset 0 0 10px rgba(255, 255, 255, 0.2);
        text-shadow: 2px 2px 0px #ff0000, -2px -2px 0px #0000ff;
        letter-spacing: 6px;
        animation: shake 0.4s infinite;
    }

    /* Fake Wikipedia Overlay */
    #fake-wiki-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: #fff;
        color: #202122;
        font-family: sans-serif;
        z-index: 9999;
        display: none;
        overflow: hidden;
        padding: 20px;
        box-sizing: border-box;
        cursor: auto;
    }
    
    #fake-wiki-overlay a { color: #3366cc; text-decoration: none; }
    #fake-wiki-overlay a:hover { text-decoration: underline; text-shadow: none; }
    
    .wiki-header { border-bottom: 1px solid #a7d7f9; padding-bottom: 0.5em; margin-bottom: 1em; }
    .wiki-logo { font-family: 'Linux Libertine', 'Georgia', 'Times', serif; font-size: 1.8em; margin-bottom: 5px; }
    .wiki-title { font-family: 'Linux Libertine', 'Georgia', 'Times', serif; font-size: 2.2em; border-bottom: 1px solid #a2a9b1; margin-bottom: 0.5em; padding-bottom: 0.2em; }
    .wiki-content { font-size: 0.95em; line-height: 1.6; max-width: 800px; }
    .wiki-sidebar { float: right; border: 1px solid #a2a9b1; background: #f8f9fa; padding: 1em; width: 250px; margin-left: 1em; font-size: 0.9em; }
    
    .wait-what {
        position: absolute;
        bottom: 20px;
        right: 20px;
        font-size: 6rem;
        color: rgba(0,0,0,0.03);
        font-weight: bold;
        pointer-events: none;
        transform: rotate(-15deg);
        animation: ghostFade 6s ease-in-out infinite;
    }

    @keyframes ghostFade {
        0%, 100% { opacity: 0; }
        50% { opacity: 1; }
    }

    .whiteout-active {
        animation: whiteout 1.5s forwards ease-in;
    }
    
    @keyframes whiteout {
        0% { filter: brightness(1) contrast(1); background-color: #000; }
        100% { filter: brightness(100) contrast(0); background-color: #fff; opacity: 0; }
    }
</style>
{% endblock %}

{% block content %}
<div id="eye-glyph">
    <div class="eye left"></div>
    <div class="eye right"></div>
</div>

<div id="void-container">
    <!-- Screams will drift here -->
</div>

<a href="#" class="return-link" id="fall-deeper-btn">FALL DEEPER</a>
<a href="{{ url_for('void.index') }}" class="return-link" id="wake-up-btn">WAKE UP</a>

<div id="fake-wiki-overlay">
    <div class="wiki-header">
        <div class="wiki-logo">Wikipedia</div>
        <small>The Free Encyclopedia</small>
    </div>
    <div class="wiki-content">
        <div class="wiki-sidebar">
            <strong>Void Entity</strong><br>
            <small>Class: Keter</small><br>
            <hr>
            <img src="https://upload.wikimedia.org/wikipedia/commons/a/a3/June_odd-eyed-cat.jpg" style="width:100%; filter: grayscale(100%) contrast(200%);" alt="Subject">
        </div>
        <h1 class="wiki-title">Semantic Saturation</h1>
        <p><b>Semantic saturation</b> (also known as <b>verbal satiation</b>) is a psychological phenomenon in which repetition causes a word or phrase to temporarily lose meaning for the listener, who then perceives the speech as repeated meaningless sounds.</p>
        <p>The phenomenon was first described by <a href="#">Leon Jakobovits James</a> in his 1962 doctoral dissertation at McGill University. He demonstrated that it is possible to reach a state of "experimental neurosis" through repetitive exposure to textual stimuli.</p>
        <h3>Process</h3>
        <p>The inspection of the void results in a breakdown of cognitive barriers. Subjects report hearing voices, specifically "screams" that form cohesive <a href="#">gestalts</a>.</p>
    </div>
    <div class="wait-what">wait what?</div>
</div>
{% endblock %}

{% block scripts %}
<script>
    const voidContainer = document.getElementById('void-container');
    const wakeUpBtn = document.getElementById('wake-up-btn');
    const fallDeeperBtn = document.getElementById('fall-deeper-btn');
    const wikiOverlay = document.getElementById('fake-wiki-overlay');
    const eyeGlyph = document.getElementById('eye-glyph');
    let sessionStartTime = Date.now();
    let monsterMode = false;
    let chaosLevel = 0;
    
    // Monster shape targets (rough "face")
    const monsterTargets = [
        {x: 30, y: 35}, // Left Eye
        {x: 70, y: 35}, // Right Eye
        {x: 50, y: 70}, // Mouth center
        {x: 35, y: 65}, // Mouth L
        {x: 65, y: 65}  // Mouth R
    ];
    
    // Zalgo text characters
    const ZALGO_UP = ['\u030d', '\u030e', '\u0304', '\u0305', '\u033f', '\u0311', '\u0306', '\u0310', '\u0352', '\u0357', '\u0351', '\u0307', '\u0308', '\u030a', '\u0342', '\u0343', '\u0344', '\u034a', '\u034b', '\u034c', '\u0303', '\u0302', '\u030c', '\u0350', '\u0300', '\u0301', '\u030b', '\u030f', '\u0312', '\u0313', '\u0314', '\u033d', '\u0309', '\u0363', '\u0364', '\u0365', '\u0366', '\u0367', '\u0368', '\u0369', '\u036a', '\u036b', '\u036c', '\u036d', '\u036e', '\u036f', '\u033e', '\u035b', '\u0346', '\u031a'];
    const ZALGO_DOWN = ['\u0316', '\u0317', '\u0318', '\u0319', '\u031c', '\u031d', '\u031e', '\u031f', '\u0320', '\u0324', '\u0325', '\u0326', '\u0329', '\u032a', '\u032b', '\u032c', '\u032d', '\u032e', '\u032f', '\u0330', '\u0331', '\u0332', '\u0333', '\u0339', '\u033a', '\u033b', '\u033c', '\u0345', '\u0347', '\u0348', '\u0349', '\u034d', '\u034e', '\u0353', '\u0354', '\u0355', '\u0356', '\u0359', '\u035a', '\u0323'];
    const ZALGO_MID = ['\u0315', '\u031b', '\u0340', '\u0341', '\u0358', '\u0321', '\u0322', '\u0327', '\u0328', '\u0334', '\u0335', '\u0336', '\u0337', '\u0338', '\u0360', '\u0361', '\u0362'];

    function corruptText(text, intensity) {
        let result = '';
        for (let i = 0; i < text.length; i++) {
            result += text[i];
            if (Math.random() < intensity) {
                const numChars = Math.floor(Math.random() * 5 * intensity) + 1;
                for (let j = 0; j < numChars; j++) {
                    const set = Math.random() < 0.3 ? ZALGO_UP : (Math.random() < 0.5 ? ZALGO_MID : ZALGO_DOWN);
                    result += set[Math.floor(Math.random() * set.length)];
                }
            }
        }
        return result;
    }

    function createScreamElement(text, ageSeconds) {
        const el = document.createElement('div');
        el.className = 'scream';
        
        const decay = Math.min(ageSeconds / 3600, 1.0);
        const sessionDuration = (Date.now() - sessionStartTime) / 1000;
        const insanity = Math.min(sessionDuration / 300, 1.0);
        
        const combinedIntensity = (decay * 0.7) + (insanity * 0.3);
        
        el.textContent = corruptText(text, combinedIntensity);
        
        const x = Math.random() * 90 + 5;
        const y = Math.random() * 90 + 5;
        const size = 1 + (Math.random() * 2) - (decay * 0.5);
        const rotation = (Math.random() - 0.5) * 20;
        
        el.style.left = `${x}vw`;
        el.style.top = `${y}vh`;
        const baseOpacity = Math.max(0.1, 1 - decay);
        el.style.fontSize = `${Math.max(0.5, size)}rem`;
        el.style.transform = `rotate(${rotation}deg)`;
        el.style.setProperty('--target-opacity', baseOpacity);
        el.style.opacity = baseOpacity;
        el.dataset.baseOpacity = baseOpacity;
        const colorBase = 200 + Math.random()*55;
        el.style.color = `rgba(${colorBase}, ${200 + Math.random()*55}, ${200 + Math.random()*55}, ${baseOpacity})`;

        el.dataset.vx = (Math.random() - 0.5) * 0.1;
        el.dataset.vy = (Math.random() - 0.5) * 0.1;
        
        voidContainer.appendChild(el);
        if (document.body.classList.contains('eyes-open')) {
            el.style.opacity = '1';
        }
        return el;
    }

    async function loadScreams() {
        try {
            const response = await fetch("{{ url_for('void.get_screams') }}");
            const data = await response.json();
            voidContainer.innerHTML = '';
            data.forEach(scream => {
                const created = new Date(scream.created_at);
                const age = (Date.now() - created) / 1000;
                createScreamElement(scream.content, age);
            });
        } catch (e) {
            console.error("The void is silent...", e);
        }
    }

    function animate() {
        const children = voidContainer.children;
        for (let el of children) {
            let x = parseFloat(el.style.left);
            let y = parseFloat(el.style.top);
            
            if (monsterMode) {
                // Monster Mode Logic: Attract to nearest target
                if (!el.targetNode) {
                    el.targetNode = monsterTargets[Math.floor(Math.random() * monsterTargets.length)];
                }
                
                const tx = el.targetNode.x;
                const ty = el.targetNode.y;
                
                // Ease towards target
                x += (tx - x) * 0.02 * chaosLevel;
                y += (ty - y) * 0.02 * chaosLevel;
                
                // Jitter
                x += (Math.random() - 0.5) * chaosLevel * 2;
                y += (Math.random() - 0.5) * chaosLevel * 2;
                
            } else {
                // Standard Drift
                x += parseFloat(el.dataset.vx);
                y += parseFloat(el.dataset.vy);
                
                if (x < -10) x = 110;
                if (x > 110) x = -10;
                if (y < -10) y = 110;
                if (y > 110) y = -10;
            }
            
            el.style.left = `${x}vw`;
            el.style.top = `${y}vh`;
            
            if (Math.random() < 0.005 + (chaosLevel * 0.1)) {
                el.style.transform = `translate(${Math.random()*10 - 5}px, ${Math.random()*10 - 5}px) rotate(${Math.random()*360}deg)`;
                if (!monsterMode) {
                    setTimeout(() => {
                        el.style.transform = `rotate(${(Math.random() - 0.5) * 20}deg)`;
                    }, 100);
                }
            }
        }
        
        const sessionDuration = (Date.now() - sessionStartTime) / 1000;
        const insanity = Math.min(sessionDuration / 600, 1.0) + chaosLevel;
        voidContainer.style.filter = `blur(${Math.max(0, insanity * 2)}px) contrast(${1 + insanity}) hue-rotate(${insanity * 90}deg)`;
        
        requestAnimationFrame(animate);
    }

    function triggerFallDeeper() {
        monsterMode = true;
        fallDeeperBtn.style.display = 'none';
        wakeUpBtn.style.display = 'none';
        
        // Phase 1: Build Chaos
        let buildUp = setInterval(() => {
            chaosLevel += 0.05;
            if (chaosLevel > 5) {
                clearInterval(buildUp);
                // Phase 2: Switch
                document.body.style.background = '#fff';
                voidContainer.style.display = 'none';
                eyeGlyph.style.display = 'none';
                wikiOverlay.style.display = 'block';
            }
        }, 200);
    }
    
    fallDeeperBtn.addEventListener('click', (e) => {
        e.preventDefault();
        triggerFallDeeper();
    });

    function setEyesOpen(state) {
        document.body.classList.toggle('eyes-open', state);
        const children = voidContainer.children;
        for (let el of children) {
            if (state) {
                if (!el.dataset.prevOpacity) {
                    el.dataset.prevOpacity = el.style.opacity;
                }
                el.style.opacity = '1';
            } else {
                const fallback = el.dataset.prevOpacity ?? el.dataset.baseOpacity ?? '';
                el.style.opacity = fallback;
                delete el.dataset.prevOpacity;
            }
        }
    }

    wakeUpBtn.addEventListener('click', (e) => {
        e.preventDefault();
        document.body.classList.add('whiteout-active');
        setTimeout(() => {
            window.location.href = "{{ url_for('void.index') }}";
        }, 1200);
    });

    eyeGlyph.addEventListener('mouseenter', () => setEyesOpen(true));
    eyeGlyph.addEventListener('mouseleave', () => setEyesOpen(false));

    // Random Blink Mode (1 in 3 chance)
    if (Math.random() < 0.33) {
        document.body.classList.add('blink-mode');
    }

    // Toggle Blink Mode
    document.addEventListener('keydown', (e) => {
        if (e.key.toLowerCase() === 'b') {
            document.body.classList.toggle('blink-mode');
        }
    });

    loadScreams();
    animate();
    setInterval(loadScreams, 30000);
</script>
{% endblock %}

